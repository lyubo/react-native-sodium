// @flow

import React, { Component } from 'react'
import {
  StyleSheet,
  Text,
  ScrollView,View,TouchableHighlight,NativeModules
} from 'react-native'

import Base64 from 'base64-js'
import Sodium from 'react-native-sodium'

class TestResult extends Component {
    render() {
      const text = (this.props.value == null) ? "?" :(this.props.value ? "Pass":"Fail")
      const style = {color:(this.props.value == null ? "black" : (this.props.value ? "green":"red"))}
      return (
        <View style={styles.testContainer}>
          <Text style={styles.testLabel}>{this.props.name}:</Text>
          <Text style={[styles.testResult,style]}>{text}</Text>
        </View>
      );
    }

  }

class TestValue extends Component {
    render() {
      return (
        <View style={styles.testContainer}>
          <Text style={styles.testLabel}>{this.props.name}:</Text>
          <Text style={[styles.testResult]}>{this.props.value}</Text>
        </View>
      );
    }

  }

export default  class Example extends Component {

  state: {
    sodium_version_string: string,
   }

  constructor(props) {
    super(props)
    this.state = {}
  }


  _handleError(error) {
    console.log(error)
    this.setState({sodiumError: error})
  }

  _testRandom1() {
    this.setState({randombytes_uniform:null})
    let freq = [];
    let p = []
    for (i = 0; i < 256; ++i) freq[i] = 0;
    for (i = 0; i < 20*256; ++i) p.push(Sodium.randombytes_uniform(256).then((v) => ++freq[v]))
    Promise.all(p).then(() => {
      var fail = false
      for (i = 0; i < 256 && !fail; ++i) if (!freq[i]) fail = true
      this.setState({randombytes_uniform:!fail})
    })
  }

  _testRandom2() {
    this.setState({randombytes_buf:null})
    let freq = [];
    for (i = 0; i < 256; ++i) freq[i] = 0;
    Sodium.randombytes_buf(20*256).then((value) => {
      let a = Base64.toByteArray(value)
      for (i = 0; i < a.length; ++i) ++freq[a[i]]
      var fail = false
      for (i = 0; i < 256 && !fail; ++i) if (!freq[i]) fail = true
      this.setState({randombytes_buf:!fail})
    })
  }

  _testRandom3() {
    this.setState({randombytes_random:null})
    let freq = [];
    let p = []
    for (i = 0; i < 256; ++i) freq[i] = 0;
    for (i = 0; i < 5*256; ++i) p.push(Sodium.randombytes_random().then((v) => {
      ++freq[v & 0xff]
      ++freq[(v >>> 8) & 0xff]
      ++freq[(v >>> 16) & 0xff]
      ++freq[(v >>> 24) & 0xff]
    }))
    Promise.all(p).then(() => {
      var fail = false
      for (i = 0; i < 256 && !fail; ++i) if (!freq[i]) fail = true
      this.setState({randombytes_random:!fail})
    })
  }

  _testAuth1() {
    const k = Base64.fromByteArray(new Uint8Array([
      // Jefe
      0x4a,0x65,0x66,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00]))

    const c = Base64.fromByteArray(new Uint8Array([
      // what do ya want for nothing?
      0x77,0x68,0x61,0x74,0x20,0x64,0x6f,0x20,0x79,0x61,0x20,0x77,0x61,0x6e,
      0x74,0x20,0x66,0x6f,0x72,0x20,0x6e,0x6f,0x74,0x68,0x69,0x6e,0x67,0x3f]))

    const a = Base64.fromByteArray(new Uint8Array([
      0x16,0x4b,0x7a,0x7b,0xfc,0xf8,0x19,0xe2,0xe3,0x95,0xfb,0xe7,0x3b,0x56,0xe0,0xa3,
      0x87,0xbd,0x64,0x22,0x2e,0x83,0x1f,0xd6,0x10,0x27,0x0c,0xd7,0xea,0x25,0x05,0x54]))

    this.setState({crypto_auth:null,crypto_auth_verify:null})

    Sodium.crypto_auth(c,k).then((aa) => {
      this.setState({crypto_auth:(a === aa)})
      Sodium.crypto_auth_verify(a,c,k)
        .then((r) => this.setState({crypto_auth_verify:(r == 0)}))
        .catch((error) => {
          this.setState({crypto_auth_verify:false})
          this._handleError(error)
        })
    }).catch((error) => {
      this.setState({crypto_auth_verify:false})
      this._handleError(error)
    })
  }

  _testBox1() {
    this.setState({crypto_box1:null})
    const mlen_max = 1000

    Promise.all([Sodium.crypto_box_keypair(),Sodium.crypto_box_keypair()]).then(([alice,bob]) => {
      let p = []
      for (mlen = 0; mlen <= mlen_max; mlen++) {
        p.push(
          Promise.all([
            Sodium.randombytes_buf(Sodium.crypto_box_NONCEBYTES),
            Sodium.randombytes_buf(mlen)
          ]).then(([n,m]) =>
             Sodium.crypto_box_easy(m,n,bob.pk,alice.sk)
              .then((c) => Sodium.crypto_box_open_easy(c,n,alice.pk,bob.sk))
              .then((mm) => mm === m))
        )
      }
      Promise.all(p).then((pr) => {
        let fail = false
        for (i = 0; i < pr.length && !fail; ++i) if (!pr[i]) fail = true
        this.setState({crypto_box1:!fail})
      })
    })
  }

  _testBox2() {
    this.setState({crypto_box2:null})
    const alicepk = Base64.fromByteArray(new Uint8Array([
      0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a,
      0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]))

    const alicesk = Base64.fromByteArray(new Uint8Array([
      0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45,
      0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]))

    const bobpk = Base64.fromByteArray(new Uint8Array([
      0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37,
      0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]))

    const bobsk = Base64.fromByteArray(new Uint8Array([
      0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6,
      0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]))

    const nonce = Base64.fromByteArray(new Uint8Array([
      0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73,0xcd,0x62,0xbd,0xa8,
      0x75,0xfc,0x73,0xd6 ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37]))

    const m = Base64.fromByteArray(new Uint8Array([
      0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b,
      0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc,
      0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29,
      0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31,
      0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57,
      0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde,
      0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52,
      0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64,
      0x5e,0x07,0x05]))

    const c =  Base64.fromByteArray(new Uint8Array([
      0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9,
      0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
      0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
      0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
      0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
      0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
      0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
      0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
      0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
      0xe3,0x55,0xa5]))

      Sodium.crypto_box_easy(m,nonce,bobpk,alicesk).then((cc) => {
        Sodium.crypto_box_open_easy(cc,nonce,alicepk,bobsk).then((mm) => {
          this.setState({crypto_box2:(c === cc && m === mm)})
        });
      });
  };


  _testSodium() {
    Sodium.sodium_version_string()
      .then((version) => this.setState({sodium_version_string: version}))
      .catch((error) => this._handleError(error))

    // Random data generation
    this._testRandom1()
    this._testRandom2()
    this._testRandom3()

    // Secret key cryptography - authentication
    this._testAuth1()

    // Public-key cryptography - authenticated encryption
    this._testBox1()
    this._testBox2()
  }

  componentWillMount() {
     this._testSodium()
  }

  render() {
    return (
      <ScrollView style={{flex:1}}>
        <TouchableHighlight onPress={() => this._testSodium()}>
          <Text style={styles.welcome}>
            Salted React Native!
          </Text>
        </TouchableHighlight>
        <TestValue name="sodium_version_string" value={this.state.sodium_version_string}/>
        <TestResult name="randombytes_random" value={this.state.randombytes_random}/>
        <TestResult name="randombytes_uniform" value={this.state.randombytes_uniform}/>
        <TestResult name="randombytes_buf" value={this.state.randombytes_buf}/>
        <TestResult name = "crypto_auth" value={this.state.crypto_auth}/>
        <TestResult name = "crypto_auth_verify" value={this.state.crypto_auth_verify}/>
        <TestResult name = "crypto_box1" value={this.state.crypto_box1}/>
        <TestResult name = "crypto_box2" value={this.state.crypto_box2}/>
      </ScrollView>
    )
  }

}

const styles = StyleSheet.create({
  container: {
    flex: 1,
   //justifyContent: 'center',
    //alignItems: 'center',
    backgroundColor: '#F5FCFF',
    padding:5
  },

  testContainer: {
    flex: 1,
    flexDirection:'row',
    padding:5
  },

  testLabel: {
    flex:4,
    textAlign: 'left',
    color: '#333333',
  },

  testResult: {
    flex:1,
    textAlign: 'center',
  },

  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  instructions: {
    textAlign: 'left',
    color: '#333333',
    marginBottom: 5,
  },
})
